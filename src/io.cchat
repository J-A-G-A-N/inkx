#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <ncurses.h>
#include "io.h"
#include "../data/gap_buffer/gap_buffer.h"
#include "../data/dynamic_array/dynamicarray.h"

#define is_ctrl(x) ((x) & 0x1f)
#define GAP_CHARACTER '\0'

static uint32_t newline_char_count = 0;
static char errorbuffer[256];


static uint32_t count = 0;

uint32_t index_of_newline(Dynamic_array* DA, int num) {
    uint32_t index = 0;
    for (int i = 0; i < num; i++) {
        index += DA->aptr[i];
    }
    return index;
}




void reset_curpos(GapBuffer* gb, uint32_t* curx) {
    if (count == 0) {
        gb->cursor_pos = 0;
        *curx = 0;
        count++;
    }
}

bool LoadFile(char * filename , Text** T) {
  FILE *file;
  int filesize;

  file = fopen(filename, "rb");


  if (!file) {
	sprintf(errorbuffer,"Could not open file %s\n", filename);
	perrorfile(errorbuffer);
    return false;
  }

  // Seek to the end of the file
  fseek(file, 0, SEEK_END);

  filesize = ftell(file);

  fclose(file);

  *T = InitText(filesize);
  file = fopen(filename, "r");

  if (!file) {
	sprintf(errorbuffer,"Could not open file %s\n", filename);
	perrorfile(errorbuffer);
    return false;
  }

  int cursor_pos = (*T)->gb->gap_start;
  char *temp = malloc(sizeof(char) * filesize);
  while (fgets(temp, sizeof(temp), file)) {
    InsertStringGB((*T)->gb, temp, cursor_pos);
    cursor_pos += strlen(temp);
  }
    free(temp); 
  return true;
}




bool SaveFile(char *filename, Text** T) {
    FILE *file = fopen(filename, "w");
    if (file == NULL) return true;

    for (int i = 0; i < (*T)->gb->gap_start; i++) {
        if ((*T)->gb->buffer[i] != GAP_CHARACTER) {
            fputc((*T)->gb->buffer[i], file);
        }
    }

    for (int i = (*T)->gb->gap_end; i < (int)(*T)->gb->buffer_size; i++) {
        if ((*T)->gb->buffer[i] != GAP_CHARACTER) {
            fputc((*T)->gb->buffer[i], file);
        }
    }

    fclose(file);
    return false;
}

uint32_t get_line_length(Text* T, uint32_t line_number) {
    uint32_t current_line = 0;
    uint32_t line_length = 0;

    for (uint32_t i = 0; i < T->gb->buffer_size; i++) {
        if (current_line == line_number) {
            if (T->gb->buffer[i] == '\n' || i == T->gb->buffer_size - 1) {
                return line_length;
            }
            if (T->gb->buffer[i] != GAP_CHARACTER) {
                line_length++;
            }
        } else if (T->gb->buffer[i] == '\n') {
            current_line++;
        }
    }

    return 0;
}

uint32_t get_total_lines(Text* T) {
    uint32_t total_lines = 1;

    for (uint32_t i = 0; i < T->gb->buffer_size; i++) {
        if (T->gb->buffer[i] == '\n') {
            total_lines++;
        }
    }

    return total_lines;
}

bool ListenKeys(int character, uint32_t *cury, uint32_t *curx, Text** T, Dynamic_array* DA, char *filename) {
    char c = (char) character;
    switch(character) {
        case is_ctrl('e'):
            return false;

        case is_ctrl('w'):
            SaveFile(filename, T);
            break;

        case KEY_UP:
            if (*cury > 0) {
                (*cury)--;
                uint32_t prev_line_length = get_line_length(*T, *cury);
                if (*curx > prev_line_length) {
                    *curx = prev_line_length;
                }
                (*T)->gb->cursor_pos = index_of_newline(DA, *cury) + *curx;
            }
            break;

        case KEY_DOWN:
            if (*cury < get_total_lines(*T) - 1) {
                (*cury)++;
                uint32_t next_line_length = get_line_length(*T, *cury);
                if (*curx > next_line_length) {
                    *curx = next_line_length;
                }
                (*T)->gb->cursor_pos = index_of_newline(DA, *cury) + *curx;
            }
            break;

        case KEY_LEFT:
            if ((*T)->gb->cursor_pos > 0) {
                (*T)->gb->cursor_pos--;
                if (*curx > 0) {
                    (*curx)--;
                } else if (*cury > 0) {
                    (*cury)--;
                    *curx = get_line_length(*T, *cury);
                }
            }
            break;

        case KEY_RIGHT:
            if ((*T)->gb->cursor_pos < (*T)->gb->buffer_size - (*T)->gb->gap_size) {
                (*T)->gb->cursor_pos++;
                uint32_t current_line_length = get_line_length(*T, *cury);
                if (*curx < current_line_length) {
                    (*curx)++;
                } else if (*cury < get_total_lines(*T) - 1) {
                    (*cury)++;
                    *curx = 0;
                }
            }
            break;

        case 10:  // Enter key
            (*cury)++;
            (*curx) = 0;
            InsertStringGB((*T)->gb, "\n", (*T)->gb->cursor_pos);
            break;

        case KEY_BACKSPACE:
            if (*curx != 0 && (*T)->gb->cursor_pos > 0) {
                (*curx)--;
                DeleteStringGB((*T)->gb, (*T)->gb->cursor_pos, 1);
                (*T)->gb->cursor_pos--;
            }
            break;

        case KEY_DC:  // Delete key
            if ((*T)->gb->cursor_pos < (*T)->gb->buffer_size - (*T)->gb->gap_size) {
                DeleteStringGB((*T)->gb, (*T)->gb->cursor_pos, 1);
            }
            break;

        default:
            reset_curpos((*T)->gb, curx);
            InsertStringGB((*T)->gb, &c, (*T)->gb->cursor_pos);
            (*curx)++;
            break;
    }

    sprintf(errorbuffer, "\n(curx, cury) = (%d, %d), cursor position: %d", *curx, *cury, (*T)->gb->cursor_pos);
    perrorfile(errorbuffer);
    move(*cury, *curx);
    return true;
}
